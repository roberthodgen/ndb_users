"""
The MIT License (MIT)

Copyright (c) 2014 Robert Hodgen

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""


import webapp2

import hashlib

import random

import string

from google.appengine.ext import ndb

from datetime import datetime, timedelta

from google.appengine.api import app_identity

from ndb_users.config import *

from urllib import urlencode

from google.appengine.ext.webapp import template



""" The number of characters a user's session ID should be. """
COOKIE_VALUE_LENGTH = 50

""" The number of characters a user's password salt (`User.passwordSalt`) should
 be. """
SALT_LENGTH = 10

""" The number of characters a user's activation token and password recovery
token should be. """
TOKEN_LENGTH = 20

""" The number of days an extended user session should remain active. Will be
set in both the cookies sent to users and value stored in ndb
(`UserSession.expires`). """
USER_SESSION_EXTENDED_DAYS = 90

""" The number of days a user's activation token remains active. """
USER_ACTIVATION_DAYS = 7

""" Tells web browsers to only send the cookie over SSL/TLS connections.
Should be set to True to protect users sessions. Note: `COOKIE_SECURE` will
be ignored in Development; see `login._user_secure_cookies()`. """
COOKIE_SECURE = True

""" Note: Enabling `ENFORCE_EMAIL_VERIFICATION` will force existing users to
verify their email addresses before logging in again. This will not disrupt
existing user sessions as `users.get_current_user()` only returns
a User object for a given (not expired) UserSession. """
ENFORCE_EMAIL_VERIFICATION = True

""" Change `SITE_NICKNAME` to the name of your site. This will be the visible
text to the `DEFAULT_CONTINUE_URI` link. """
SITE_NICKNAME = 'Home'

""" Change `DEFAULT_CONTINUE_URI` to the URI ndb_users should redirect users
upon successful login, logout, register, or other action. Note: this does not
override the `continue` GET parameter, `DEFAULT_CONTINUE_URI` is used when
no `continue` GET parameter is specified. """
DEFAULT_CONTINUE_URI = '/'

""" The email address user activation and password recovery emails come from.
Note: this must be either *@appid.appspotmail.com or a project
administrator's email address. When set to False the email sender will be
autogenerated via `users._email_sender()`. """
EMAIL_SENDER = False


""" Warning: Changing the following will break ndb_login unless changes are made
elsewhere! You have been warned... """
LOGIN_URI = '/_login' # Advanced setting


def get_current_user():
  """ Returns a User object or None. """
  request = webapp2.get_request()
  cookie_value = request.cookies.get(NDB_USERS_COOKIE_KEY)
  if not cookie_value:
    # Generate a Cookie ID...
    return None
  else:
    # Cookie found, validate it!
    user_session = UserSession.user_session_for_id(cookie_value)
    if user_session:
      # Found a UserSession live in ndb...
      if user_session.expires > datetime.now():
        user_key = ndb.Key(User, user_session.userId)
        return user_key.get()
      else:
        return None
    else:
      # Not found
      return None

def create_logout_url(redirect_uri=None):
  """ Destroys the User's session and redirects to `redirect_uri`. """
  if redirect_uri:
    return ''.join([LOGIN_URI, '?', urlencode({
        'action': 'logout',
        'continue': redirect_uri
      })])
  return ''.join([LOGIN_URI, '?action=logout'])

def create_login_url(redirect_uri=None):
  """ A login page, upon successful login will redirect to `redirect_uri`. """
  if redirect_uri:
    return ''.join([LOGIN_URI, '?', urlencode({
        'continue': redirect_uri
      })])
  return LOGIN_URI

def create_password_change_url(redirect_uri=None):
  """ Return a URL for changing the user's password. Redirect optional. """
  if redirect_uri:
    return ''.join([NDB_USERS_LOGIN_PASSWORD_CHANGE_URI,
      '?continue=', redirect_uri])
  else:
    return NDB_USERS_LOGIN_PASSWORD_CHANGE_URI

def _append_query(base, query):
  """ Append `query` to `base` if `query` has length. """
  if query:
    return ''.join([base, '?', query])
  return base

def template_values(template_values=dict(), query_options=dict()):
  """ Return `template_values` plus the default key-value pairs. """
  request = webapp2.get_request()
  continue_uri = request.GET.get('continue')
  if continue_uri:
    query_options['continue'] = continue_uri
    template_values.update(continue_uri=continue_uri)
  logout_query_options = query_options.copy()
  logout_query_options['action'] = 'logout'
  user = get_current_user()
  if user:
    # Default key-value pairs with logged in user
    template_values.update(user={ 'email': user.email },
      logout_uri=_append_query(NDB_USERS_LOGIN_URI, urlencode(logout_query_options)),
      password_change_uri=_append_query(NDB_USERS_LOGIN_PASSWORD_CHANGE_URI, urlencode(query_options)),
      password_forgot_uri=_append_query(NDB_USERS_LOGIN_PASSWORD_RESET_URI, urlencode(query_options))
    )
  else:
    # Default key-value pairs with no user
    template_values.update(
        login_uri=_append_query(NDB_USERS_LOGIN_URI, urlencode(query_options)),
        create_uri=_append_query(NDB_USERS_LOGIN_CREATE_URI, urlencode(query_options)),
        password_forgot_uri=_append_query(NDB_USERS_LOGIN_PASSWORD_RESET_URI, urlencode(query_options))
      )
  return template_values

def _user_id_for_email(email):
  """ Return a hash for `email`. """
  return hashlib.sha256(email).hexdigest()

def _password_hash(password, salt):
  """ Return a hash of the User's `password` and `salt`. """
  return hashlib.sha256(''.join([password, salt])).hexdigest()

def _user_verified(user):
  """ Return True if `user.verified` is True or
  `users.ENFORCE_EMAIL_VERIFICATION` is False.
  """
  if ENFORCE_EMAIL_VERIFICATION:
    return bool(user.verified)
  else:
    return True

def _email_sender():
  """ Returns the email address all account activation and password recovery
  emails will come from (sender). See `users.EMAIL_SENDER`. """
  if EMAIL_SENDER:
    return EMAIL_SENDER
  else:
    # Construct using the Application ID
    return ''.join([
      'accounts@', app_identity.get_application_id(), '.appspotmail.com'])

def error_handler_unauthorized(request, response, exception):
  """ Used for handling an HTTP/1.1 401 Unauthorized error. Will display the
  login page with a message prompting the user to log in. """
  response.set_status(401)
  response.out.write(template.render(
      'ndb_users/templates/401-unauthorized.html',
      template_values(query_options={
          'continue': request.path
        })
    ))


class User(ndb.Model):
  """ User class defines a user. """

  email = ndb.StringProperty(required=True)
  passwordHash = ndb.StringProperty(required=True)
  passwordSalt = ndb.StringProperty(required=True)
  active = ndb.BooleanProperty(default=False)
  verified = ndb.BooleanProperty(default=False)
  created = ndb.DateTimeProperty(auto_now_add=True)
  updated = ndb.DateTimeProperty(auto_now=True)

  @classmethod
  @ndb.transactional
  def create_user(cls, email, password):
    """ Used to create a new User in the ndb database. """
    email = email.lower() # Lowercase email address!
    new_user = User(
      key=ndb.Key(User, _user_id_for_email(email)),
      email=email,
      verified=not ENFORCE_EMAIL_VERIFICATION
    )
    return new_user.update_password(password)

  def __eq__(self, other)  :
    """ Overrides default equality check (==)."""
    # Compare the User's User ID
    return self.__class__.__name__+self.user_id() == other

  @ndb.transactional
  def update_password(self, new_password):
    """ Update this user's password to `new_password`. """
    password_salt = User._generate_password_salt()
    self.passwordSalt = password_salt
    self.passwordHash = _password_hash(new_password, password_salt)
    return self.put()

  @classmethod
  def _generate_password_salt(cls):
    return ''.join(random.SystemRandom().sample(''.join([string.digits,
      string.letters, string.punctuation]), SALT_LENGTH))


class UserSession(ndb.Model):
  """ UserSession class stores a User's session IDs (`user_session_id` cookie)
  and associates them with a User (via the User's `key`). """

  userId = ndb.StringProperty(required=True)
  created = ndb.DateTimeProperty(auto_now_add=True)
  expires = ndb.DateTimeProperty(required=True)

  @classmethod
  def user_session_for_id(cls, user_session_id):
    """ Find a UserSession object for `user_session_id`. """
    key = ndb.Key(UserSession, user_session_id)
    return key.get()

  @classmethod
  def _generate_session_id(cls):
    return ''.join(random.SystemRandom().sample(
      ''.join([string.ascii_letters, string.digits]), COOKIE_VALUE_LENGTH))

  @classmethod
  def create_user_session(cls, user_id):
    """ Creates a new UserSession in the ndb database for a given `user_id`. """
    new_user_session = UserSession(
      key=ndb.Key(UserSession, UserSession._generate_session_id()),
      userId=user_id,
      expires = datetime.now() + timedelta(days=USER_SESSION_EXTENDED_DAYS)
    )
    return new_user_session.put()


class UserActivation(ndb.Model):
  """ UserActivation class stores a User's activation token and associates them
  with a User (via the User's `key`). """

  userId = ndb.StringProperty(required=True)
  created = ndb.DateTimeProperty(auto_now_add=True)
  expires = ndb.DateTimeProperty(required=True)

  @classmethod
  def create_user_activation(cls, user_id):
    """ Create a new UserActivation in the ndb datastore for a given
    `user_id`. """
    new_user_activation = UserActivation(
      key=ndb.Key(UserActivation, UserActivation._generate_activation_token()),
      userId=user_id,
      expires = datetime.now() + timedelta(days=USER_ACTIVATION_DAYS)
    )
    return new_user_activation.put()

  @ndb.transactional(xg=True)
  def activate_user(self):
    """ Activate the User this UserActivation is assigned to and delete this
    UserActivation from the datastore. """
    user = ndb.Key(User, self.userId).get()
    if user:
      user.verified = True
      user.put()
      self.key.delete()
      return user

    return None


  @classmethod
  def _generate_activation_token(cls):
    return ''.join(random.SystemRandom().sample(string.hexdigits, TOKEN_LENGTH))
